// SPDX-License-Identifier: MIT
// Copyright (c) 2026 Eshan Roy <eshanized@proton.me>
//
// AGEN - AI Agent Template Manager
// A cross-platform CLI tool for managing AI agent templates

package ide

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/eshanized/agen/internal/templates"
)

// NeovimAdapter handles Neovim configurations for AI plugins.
// Supports various LLM plugins like:
// - ChatGPT.nvim
// - Copilot.vim
// - avante.nvim
// - codecompanion.nvim
type NeovimAdapter struct{}

// Name returns the adapter name
func (n *NeovimAdapter) Name() string {
	return "Neovim"
}

// Detect checks if this is a Neovim-managed project.
// Look for .nvim.lua or .nvim/ folder.
func (n *NeovimAdapter) Detect(projectPath string) bool {
	// Check for project-local nvim config
	nvimLua := filepath.Join(projectPath, ".nvim.lua")
	if _, err := os.Stat(nvimLua); err == nil {
		return true
	}
	nvimDir := filepath.Join(projectPath, ".nvim")
	if info, err := os.Stat(nvimDir); err == nil && info.IsDir() {
		return true
	}
	// Also check for exrc
	exrcFile := filepath.Join(projectPath, ".exrc")
	if _, err := os.Stat(exrcFile); err == nil {
		return true
	}
	return false
}

// Install creates Neovim AI configuration from templates.
func (n *NeovimAdapter) Install(tmpl *templates.Templates, opts InstallOptions) error {
	nvimDir := filepath.Join(opts.TargetDir, ".nvim")
	rulesFile := filepath.Join(nvimDir, "ai-rules.md")

	if _, err := os.Stat(nvimDir); err == nil && !opts.Force {
		if opts.DryRun {
			return nil
		}
		return fmt.Errorf("neovim config %s already exists (use --force to overwrite)", nvimDir)
	}

	if opts.DryRun {
		return nil
	}

	// Create .nvim directory
	if err := os.MkdirAll(nvimDir, 0755); err != nil {
		return err
	}

	// Create ai-rules.md
	rulesContent := n.buildRulesContent(tmpl)
	if err := os.WriteFile(rulesFile, []byte(rulesContent), 0644); err != nil {
		return err
	}

	// Create .nvim.lua with basic config
	nvimLuaContent := n.buildNvimLua()
	nvimLuaFile := filepath.Join(opts.TargetDir, ".nvim.lua")
	return os.WriteFile(nvimLuaFile, []byte(nvimLuaContent), 0644)
}

// buildRulesContent creates the AI rules content
func (n *NeovimAdapter) buildRulesContent(tmpl *templates.Templates) string {
	var sb strings.Builder

	sb.WriteString("# Neovim AI Rules - Generated by AGEN\n\n")
	sb.WriteString("> This file provides context for Neovim AI plugins.\n")
	sb.WriteString("> Generated by AGEN (https://github.com/eshanized/agen)\n\n")
	sb.WriteString("---\n\n")

	// Code standards
	sb.WriteString("## Coding Standards\n\n")
	sb.WriteString("- Follow clean code principles\n")
	sb.WriteString("- Use meaningful variable and function names\n")
	sb.WriteString("- Keep functions small and focused\n")
	sb.WriteString("- Write tests for new functionality\n\n")

	// Agents
	sb.WriteString("## Available Agents\n\n")
	for name, agent := range tmpl.Agents {
		sb.WriteString("### ")
		sb.WriteString(name)
		sb.WriteString("\n")
		sb.WriteString(agent.Description)
		sb.WriteString("\n\n")
	}

	// Skills
	sb.WriteString("## Skills\n\n")
	for name, skill := range tmpl.Skills {
		sb.WriteString("- **")
		sb.WriteString(name)
		sb.WriteString("**: ")
		sb.WriteString(skill.Description)
		sb.WriteString("\n")
	}
	sb.WriteString("\n")

	// Workflows
	sb.WriteString("## Commands\n\n")
	for name, workflow := range tmpl.Workflows {
		displayName := name
		if !strings.HasPrefix(name, "/") {
			displayName = "/" + name
		}
		sb.WriteString("- `")
		sb.WriteString(displayName)
		sb.WriteString("`: ")
		sb.WriteString(workflow.Description)
		sb.WriteString("\n")
	}

	return sb.String()
}

// buildNvimLua creates project-local Neovim config
func (n *NeovimAdapter) buildNvimLua() string {
	return `-- Project-local Neovim config - Generated by AGEN
-- This file is loaded automatically with exrc/secure settings

-- Set project-specific options
vim.opt_local.tabstop = 2
vim.opt_local.shiftwidth = 2
vim.opt_local.expandtab = true

-- AI plugin context (update path based on your plugin)
-- For codecompanion.nvim:
-- vim.g.codecompanion_context_file = ".nvim/ai-rules.md"

-- For avante.nvim:
-- vim.g.avante_context = vim.fn.readfile(".nvim/ai-rules.md")

return {
  -- AGEN managed project
  agen = true,
  ai_rules = ".nvim/ai-rules.md",
}
`
}

// Update updates Neovim configuration
func (n *NeovimAdapter) Update(tmpl *templates.Templates, opts UpdateOptions) (*UpdateChanges, error) {
	changes := &UpdateChanges{}
	rulesFile := filepath.Join(opts.TargetDir, ".nvim", "ai-rules.md")

	if _, err := os.Stat(rulesFile); os.IsNotExist(err) {
		if err := n.Install(tmpl, InstallOptions{
			TargetDir: opts.TargetDir,
			DryRun:    opts.DryRun,
			Force:     true,
		}); err != nil {
			return nil, err
		}
		changes.Added = append(changes.Added, ".nvim/ai-rules.md", ".nvim.lua")
	} else {
		if opts.Force || opts.DryRun {
			rulesContent := n.buildRulesContent(tmpl)
			if !opts.DryRun {
				if err := os.WriteFile(rulesFile, []byte(rulesContent), 0644); err != nil {
					return nil, err
				}
			}
			changes.Updated = append(changes.Updated, ".nvim/ai-rules.md")
		} else {
			changes.Skipped = append(changes.Skipped, ".nvim/ai-rules.md")
		}
	}

	return changes, nil
}

// GetRulesPath returns the path to the rules file
func (n *NeovimAdapter) GetRulesPath() string {
	return ".nvim/ai-rules.md"
}
