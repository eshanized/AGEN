// SPDX-License-Identifier: MIT
// Copyright (c) 2026 Eshan Roy <eshanized@proton.me>
//
// AGEN - AI Agent Template Manager
// A cross-platform CLI tool for managing AI agent templates

package ide

import (
	"os"
	"path/filepath"
	"strings"

	"github.com/eshanized/agen/internal/templates"
)

// WindsurfAdapter handles Windsurf IDE format.
// Windsurf uses .windsurfrules file, similar to Cursor.
// The format is basically the same as Cursor, just different filename.
type WindsurfAdapter struct{}

// Name returns the adapter name
func (w *WindsurfAdapter) Name() string {
	return "Windsurf"
}

// Detect checks for .windsurfrules file
func (w *WindsurfAdapter) Detect(projectPath string) bool {
	rulesFile := filepath.Join(projectPath, ".windsurfrules")
	if _, err := os.Stat(rulesFile); err == nil {
		return true
	}
	return false
}

// Install creates the .windsurfrules file from templates.
// similar to Cursor, but with Windsurf-specific header.
func (w *WindsurfAdapter) Install(tmpl *templates.Templates, opts InstallOptions) error {
	rulesFile := filepath.Join(opts.TargetDir, ".windsurfrules")

	if _, err := os.Stat(rulesFile); err == nil && !opts.Force {
		if opts.DryRun {
			return nil
		}
	}

	content := w.buildRulesContent(tmpl)

	if opts.DryRun {
		return nil
	}

	return os.WriteFile(rulesFile, []byte(content), 0644)
}

// buildRulesContent creates Windsurf-specific rules content
func (w *WindsurfAdapter) buildRulesContent(tmpl *templates.Templates) string {
	var sb strings.Builder

	// Windsurf header
	sb.WriteString("# Windsurf Rules - Generated by AGEN\n\n")
	sb.WriteString("> Generated by AGEN (AI Agent Template Manager)\n")
	sb.WriteString("> https://github.com/eshanized/agen\n\n")
	sb.WriteString("---\n\n")

	// Global rules
	sb.WriteString("## Core Principles\n\n")
	sb.WriteString("- **Clean Code**: Keep it simple, readable, maintainable\n")
	sb.WriteString("- **Security First**: Always consider security implications\n")
	sb.WriteString("- **Test Everything**: Write tests for critical functionality\n")
	sb.WriteString("- **Document Intent**: Explain WHY, not just WHAT\n\n")

	// Agents section
	sb.WriteString("## Specialist Agents\n\n")
	for name, agent := range tmpl.Agents {
		sb.WriteString("### @")
		sb.WriteString(name)
		sb.WriteString("\n")
		sb.WriteString(agent.Description)
		sb.WriteString("\n\n")
	}

	// Skills (condensed)
	sb.WriteString("## Domain Skills\n\n")
	sb.WriteString("| Skill | Purpose |\n")
	sb.WriteString("|-------|--------|\n")
	for name, skill := range tmpl.Skills {
		sb.WriteString("| ")
		sb.WriteString(name)
		sb.WriteString(" | ")
		sb.WriteString(skill.Description)
		sb.WriteString(" |\n")
	}
	sb.WriteString("\n")

	// Workflows
	sb.WriteString("## Commands\n\n")
	for name, workflow := range tmpl.Workflows {
		displayName := name
		if !strings.HasPrefix(name, "/") {
			displayName = "/" + name
		}
		sb.WriteString("- **")
		sb.WriteString(displayName)
		sb.WriteString("** - ")
		sb.WriteString(workflow.Description)
		sb.WriteString("\n")
	}

	return sb.String()
}

// Update updates the .windsurfrules file
func (w *WindsurfAdapter) Update(tmpl *templates.Templates, opts UpdateOptions) (*UpdateChanges, error) {
	changes := &UpdateChanges{}

	rulesFile := filepath.Join(opts.TargetDir, ".windsurfrules")

	if _, err := os.Stat(rulesFile); os.IsNotExist(err) {
		if err := w.Install(tmpl, InstallOptions{
			TargetDir: opts.TargetDir,
			DryRun:    opts.DryRun,
			Force:     true,
		}); err != nil {
			return nil, err
		}
		changes.Added = append(changes.Added, ".windsurfrules")
	} else {
		if opts.Force || opts.DryRun {
			if err := w.Install(tmpl, InstallOptions{
				TargetDir: opts.TargetDir,
				DryRun:    opts.DryRun,
				Force:     true,
			}); err != nil {
				return nil, err
			}
			changes.Updated = append(changes.Updated, ".windsurfrules")
		} else {
			changes.Skipped = append(changes.Skipped, ".windsurfrules")
		}
	}

	return changes, nil
}

// GetRulesPath returns the path to the rules file
func (w *WindsurfAdapter) GetRulesPath() string {
	return ".windsurfrules"
}
