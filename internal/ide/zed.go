// SPDX-License-Identifier: MIT
// Copyright (c) 2026 Eshan Roy <eshanized@proton.me>
//
// AGEN - AI Agent Template Manager
// A cross-platform CLI tool for managing AI agent templates

package ide

import (
	"encoding/json"
	"os"
	"path/filepath"

	"github.com/eshanized/agen/internal/templates"
)

// ZedAdapter handles Zed Editor format.
// Zed uses .zed/settings.json for project configuration and
// can also use .zed/prompts/ for custom prompts/instructions.
type ZedAdapter struct{}

// Name returns the adapter name
func (z *ZedAdapter) Name() string {
	return "Zed"
}

// Detect checks for .zed/ folder
func (z *ZedAdapter) Detect(projectPath string) bool {
	zedDir := filepath.Join(projectPath, ".zed")
	if info, err := os.Stat(zedDir); err == nil && info.IsDir() {
		return true
	}
	return false
}

// ZedSettings represents Zed's settings.json structure
type ZedSettings struct {
	Assistant *ZedAssistant `json:"assistant,omitempty"`
	LSP       interface{}   `json:"lsp,omitempty"`
}

// ZedAssistant configures Zed's AI assistant
type ZedAssistant struct {
	DefaultModel    map[string]string `json:"default_model,omitempty"`
	Version         string            `json:"version,omitempty"`
	ButtonEnabled   bool              `json:"button,omitempty"`
	DockPosition    string            `json:"dock,omitempty"`
	DefaultContexts []string          `json:"default_contexts,omitempty"`
	PromptDirectory string            `json:"prompts_directory,omitempty"`
}

// Install creates Zed configuration files from templates.
//
// How it works:
// 1. Create .zed/ directory
// 2. Generate settings.json with assistant configuration
// 3. Create prompts/ folder with agent instructions
//
// Zed is unique because it supports multiple prompt files,
// so we can keep agents somewhat separate unlike Cursor/Windsurf.
func (z *ZedAdapter) Install(tmpl *templates.Templates, opts InstallOptions) error {
	zedDir := filepath.Join(opts.TargetDir, ".zed")
	promptsDir := filepath.Join(zedDir, "prompts")

	if opts.DryRun {
		return nil
	}

	// Create directories
	if err := os.MkdirAll(promptsDir, 0755); err != nil {
		return err
	}

	// Create settings.json
	settings := ZedSettings{
		Assistant: &ZedAssistant{
			Version:         "2",
			ButtonEnabled:   true,
			DockPosition:    "right",
			PromptDirectory: ".zed/prompts",
		},
	}

	settingsData, err := json.MarshalIndent(settings, "", "  ")
	if err != nil {
		return err
	}

	if err := os.WriteFile(filepath.Join(zedDir, "settings.json"), settingsData, 0644); err != nil {
		return err
	}

	// Create prompt files for each agent
	for name, agent := range tmpl.Agents {
		promptContent := z.buildPromptContent(name, agent)
		promptFile := filepath.Join(promptsDir, name+".md")
		if err := os.WriteFile(promptFile, []byte(promptContent), 0644); err != nil {
			return err
		}
	}

	// Create a main rules prompt
	mainPrompt := z.buildMainPrompt(tmpl)
	if err := os.WriteFile(filepath.Join(promptsDir, "rules.md"), []byte(mainPrompt), 0644); err != nil {
		return err
	}

	return nil
}

// buildPromptContent creates a prompt file for an agent
func (z *ZedAdapter) buildPromptContent(name string, agent templates.Agent) string {
	return "# " + name + "\n\n" + agent.Description + "\n\n" + agent.Content
}

// buildMainPrompt creates the main rules prompt
func (z *ZedAdapter) buildMainPrompt(tmpl *templates.Templates) string {
	content := `# AGEN Rules for Zed

> Generated by AGEN (AI Agent Template Manager)

## Available Agents

Use these specialists by mentioning them in your prompts:

`
	for name, agent := range tmpl.Agents {
		content += "- **" + name + "**: " + agent.Description + "\n"
	}

	content += "\n## Skills\n\n"
	for name, skill := range tmpl.Skills {
		content += "- **" + name + "**: " + skill.Description + "\n"
	}

	return content
}

// Update updates Zed configuration
func (z *ZedAdapter) Update(tmpl *templates.Templates, opts UpdateOptions) (*UpdateChanges, error) {
	changes := &UpdateChanges{}

	zedDir := filepath.Join(opts.TargetDir, ".zed")

	if _, err := os.Stat(zedDir); os.IsNotExist(err) {
		if err := z.Install(tmpl, InstallOptions{
			TargetDir: opts.TargetDir,
			DryRun:    opts.DryRun,
			Force:     true,
		}); err != nil {
			return nil, err
		}
		changes.Added = append(changes.Added, ".zed/")
	} else {
		if opts.Force {
			if err := z.Install(tmpl, InstallOptions{
				TargetDir: opts.TargetDir,
				DryRun:    opts.DryRun,
				Force:     true,
			}); err != nil {
				return nil, err
			}
			changes.Updated = append(changes.Updated, ".zed/")
		} else {
			changes.Skipped = append(changes.Skipped, ".zed/")
		}
	}

	return changes, nil
}

// GetRulesPath returns the main config path
func (z *ZedAdapter) GetRulesPath() string {
	return ".zed/settings.json"
}
